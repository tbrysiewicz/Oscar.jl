<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Elements · Oscar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../../assets/documenter.js"></script><script src="../../../../../siteinfo.js"></script><script src="../../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Oscar.jl</span></div><form class="docs-search" action="../../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../../">Welcome to Oscar</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/rings/">Ring Interface</a></li><li><a class="tocitem" href="../../../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/polynomial/">Generic univariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/mpolynomial/">Generic sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox" checked/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../orders/">Orders</a></li><li class="is-active"><a class="tocitem" href>Elements</a><ul class="internal"><li><a class="tocitem" href="#Creation"><span>Creation</span></a></li><li><a class="tocitem" href="#Basic-properties"><span>Basic properties</span></a></li><li><a class="tocitem" href="#Arithmetic"><span>Arithmetic</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li></ul></li><li><a class="tocitem" href="../ideals/">Ideals</a></li><li><a class="tocitem" href="../frac_ideals/">Fractional ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/series_rings/">Series Ring Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/series/">Generic power series</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../../../../Nemo/docs/src/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../../../../Nemo/docs/src/puiseux/">Puiseux series</a></li></ul></li><li><a class="tocitem" href="../../../../../Rings/affine/">Affine Rings</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../../../../Rings/rational/">Rationals</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../number_fields/intro/">Number Fields</a></li><li><a class="tocitem" href="../../number_fields/basics/">-</a></li><li><a class="tocitem" href="../../number_fields/elements/">-</a></li></ul></li><li><a class="tocitem" href="../../FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fraction_fields/">Fraction Field Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-3-9" type="checkbox"/><label class="tocitem" for="menuitem-3-9"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../Nemo/docs/src/padic/">Padics</a></li><li><a class="tocitem" href="../../../../../Nemo/docs/src/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../../../../Nemo/docs/src/finitefield/">Finite fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../../../../../Groups/groups/">Groups</a></li><li><a class="tocitem" href="../../abelian/introduction/">Abelian Groups</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/matrix_spaces/">Matrix Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/matrix/">Generic matrices</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/module/">Module Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../quad_forms/basics/">Basics</a></li><li><a class="tocitem" href="../../quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Rings</a></li><li><a class="is-disabled">Orders</a></li><li class="is-active"><a href>Elements</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Elements</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Elements"><a class="docs-heading-anchor" href="#Elements">Elements</a><a id="Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Elements" title="Permalink"></a></h1><p>Elements in orders have two representations: they can be viewed as  elements in the <span>$Z^n$</span> giving the coefficients wrt to the order basis where they are elements in. On the other hand, as every order is in a field, they also have a representation as number field elements. Since, asymptotically, operations are more efficient in the  field (due to fast polynomial arithmetic) than in the order, the primary representation is that as a field element.</p><h2 id="Creation"><a class="docs-heading-anchor" href="#Creation">Creation</a><a id="Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Creation" title="Permalink"></a></h2><p>Elements are constructed either as linear combinations of basis elements or via explicit coercion. Elements will be of type <code>NfOrdElem</code>,  the type if actually parametrized by the type of the surrounding field and the type of the field elements. E.g. the type of any element in any order of an absolute simple field will be <code>NfAbsOrdElem{AnticNumberField,nf_elem}</code></p><article class="docstring"><header><a class="docstring-binding" id="Hecke.NfAbsOrd" href="#Hecke.NfAbsOrd"><code>Hecke.NfAbsOrd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">  (O::NfOrd)(a::Union{fmpz, Integer}) -&gt; NfAbsOrdElem</code></pre><p>Given an element <span>$a$</span> of type <code>fmpz</code> or <code>Integer</code>, this function coerces the element into <span>$\mathcal O$</span>. It will be checked that <span>$a$</span> is contained in <span>$\mathcal O$</span> if and only if <code>check</code> is <code>true</code>.</p></div></section><section><div><pre><code class="language-none">  (O::NfOrd)(arr::Array{fmpz, 1})</code></pre><p>Returns the element of <span>$\mathcal O$</span> with coefficient vector <code>arr</code>.</p></div></section><section><div><pre><code class="language-none">  (O::NfOrd)() -&gt; NfAbsOrdElem</code></pre><p>This function constructs a new element of <span>$\mathcal O$</span> which is set to <span>$0$</span>.</p></div></section></article><h2 id="Basic-properties"><a class="docs-heading-anchor" href="#Basic-properties">Basic properties</a><a id="Basic-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.parent-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.parent-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parent(g::Perm)</code></pre><p>Return the parent of the permutation <code>g</code>.</p><pre><code class="language-julia-repl">julia&gt; G = SymmetricGroup(5); g = Perm([3,4,5,2,1])
(1,3,5)(2,4)

julia&gt; parent(g) == G
true</code></pre></div></section><section><div><pre><code class="language-none">parent(a::AbstractAlgebra.MatElem{T}, cached::Bool = true) where T &lt;: RingElement</code></pre><p>Return the parent object of the given matrix.</p></div></section><section><div><pre><code class="language-none">parent(a::AbstractAlgebra.MatAlgElem{T}, cached::Bool = true) where T &lt;: RingElement</code></pre><p>Return the parent object of the given matrix.</p></div></section><section><div><pre><code class="language-none">parent(a::NfAbsOrdElem) -&gt; NfOrd</code></pre><p>Returns the order of which <span>$a$</span> is an element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.elem_in_nf-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Hecke.elem_in_nf-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Hecke.elem_in_nf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elem_in_nf(a::NfAbsOrdElem) -&gt; nf_elem</code></pre><p>Returns the element <span>$a$</span> considered as an element of the ambient number field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.coordinates-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Hecke.coordinates-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Hecke.coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coordinates(a::NfAbsOrdElem) -&gt; Array{fmpz, 1}</code></pre><p>Returns the coefficient vector of <span>$a$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.discriminant-Tuple{Array{NfAbsOrdElem{AnticNumberField,nf_elem},1}}" href="#AbstractAlgebra.Generic.discriminant-Tuple{Array{NfAbsOrdElem{AnticNumberField,nf_elem},1}}"><code>AbstractAlgebra.Generic.discriminant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discriminant(g::Vector)</code></pre><p>Compute the product of all differences of distinct elements in the array.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/f81f8b746598fed0aec7ebb29abe6a688c2fb0e1/experimental/GaloisGrp/GaloisGrp.jl#L167">source</a></section><section><div><pre><code class="language-none">discriminant(B::Array{NfAbsOrdElem, 1}) -&gt; fmpz</code></pre><p>Returns the discriminant of the family <span>$B$</span>.</p></div></section><section><div><pre><code class="language-none">discriminant(O::AlgssRelOrd)</code></pre><p>Returns the discriminant of <span>$O$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.:==-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(x::NfAbsOrdElem, y::NfAbsOrdElem) -&gt; Bool</code></pre><p>Returns whether <span>$x$</span> and <span>$y$</span> are equal.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zero-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.zero-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero(O::NfOrd) -&gt; NfAbsOrdElem</code></pre><p>Returns the zero element of <span>$\mathcal O$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.one-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}" href="#Base.one-Tuple{NfAbsOrd{AnticNumberField,nf_elem}}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">one(O::NfOrd) -&gt; NfAbsOrdElem</code></pre><p>Returns the one element of <span>$\mathcal O$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iszero-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.iszero-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iszero(v::AbstractAlgebra.FPModuleElem{T}) where T &lt;: RingElement</code></pre><p>Return true if <span>$v$</span> is the zero element of the module <span>$M$</span>.</p></div></section><section><div><pre><code class="language-none">iszero(a::NfOrd) -&gt; Bool</code></pre><p>Tests if <span>$a$</span> is zero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isone-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.isone-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isone(a::NfOrd) -&gt; Bool</code></pre><p>Tests if <span>$a$</span> is one.</p></div></section></article><h2 id="Arithmetic"><a class="docs-heading-anchor" href="#Arithmetic">Arithmetic</a><a id="Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.:--Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">-(a::AbstractAlgebra.ResElem{T}, b::AbstractAlgebra.ResElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbstractAlgebra.ResElem{T}, b::T) where {T &lt;: RingElem}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::T, b::AbstractAlgebra.ResElem{T}) where {T &lt;: RingElem}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbstractAlgebra.ResFieldElem{T}, b::AbstractAlgebra.ResFieldElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbstractAlgebra.ResFieldElem{T}, b::T) where {T &lt;: RingElem}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::T, b::AbstractAlgebra.ResFieldElem{T}) where {T &lt;: RingElem}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbstractAlgebra.PolyElem{T}, b::AbstractAlgebra.PolyElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbstractAlgebra.NCPolyElem{T}, b::AbstractAlgebra.NCPolyElem{T}) where {T &lt;: NCRingElem}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbstractAlgebra.RelSeriesElem{T}, b::AbstractAlgebra.RelSeriesElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbstractAlgebra.AbsSeriesElem{T}, b::AbstractAlgebra.AbsSeriesElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::Generic.LaurentSeriesElem{T}, b::Generic.LaurentSeriesElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(x::Generic.MatrixElem{T}, y::Generic.MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return <span>$x - y$</span>.</p></div></section><section><div><pre><code class="language-none">-(x::T, y::Generic.MatrixElem{T}) where {T &lt;: RingElem}</code></pre><p>Return <span>$S(x) - y$</span> where <span>$S$</span> is the parent of <span>$y$</span>.</p></div></section><section><div><pre><code class="language-none">-(x::Generic.MatrixElem{T}, y::T) where {T &lt;: RingElem}</code></pre><p>Return <span>$x - S(y)$</span>, where <span>$S$</span> is the parent of <span>$a$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbstractAlgebra.FracElem{T}, b::AbstractAlgebra.FracElem{T}) where {T &lt;: RingElem}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbstractAlgebra.FracElem{T}, b::T) where {T &lt;: RingElem}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::T, b::AbstractAlgebra.FracElem{T}) where {T &lt;: RingElem}</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(x::NfAbsOrdElem) -&gt; NfAbsOrdElem</code></pre><p>Returns the additive inverse of <span>$x$</span>.</p></div></section><section><div><pre><code class="language-julia">-(A::SMat, B::SMat) -&gt; SMat</code></pre><p>Return the difference <span>$A - B$</span>.</p></div></section><section><div><pre><code class="language-none">-(A::SRow, B::SRow) -&gt; SRow</code></pre><p>Returns the difference of <span>$A$</span> and <span>$B$</span>.</p></div></section><section><div><pre><code class="language-none">-(A::SRow) -&gt; SRow</code></pre><p>Returns the negative of <span>$A$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbsAlgAssElem) -&gt; AbsAlgAssElem</code></pre><p>Returns <span>$-a$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AbsAlgAssElem, b::AbsAlgAssElem) -&gt; AbsAlgAssElem</code></pre><p>Return <span>$a - b$</span>.</p></div></section><section><div><pre><code class="language-none">-(a::AlgMatElem, b::AlgMatElem) -&gt; AlgMatElem</code></pre><p>Return <span>$a - b$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.:+-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">+(x::NfAbsOrdElem, y::NfAbsOrdElem) -&gt; NfAbsOrdElem</code></pre><p>Returns <span>$x + y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.:--Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">-(x::NfAbsOrdElem, y::NfAbsOrdElem) -&gt; NfAbsOrdElem</code></pre><p>Returns <span>$x - y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Base.:*-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(x::NfAbsOrdElem, y::NfAbsOrdElem) -&gt; NfAbsOrdElem</code></pre><p>Returns <span>$x \cdot y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Base.:^-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">^(x::NfAbsOrdElem, y::Int)</code></pre><p>Returns <span>$x^y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mod-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Base.mod-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Base.mod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mod(a::NfAbsOrdElem, m::Union{fmpz, Int}) -&gt; NfAbsOrdElem</code></pre><p>Reduces the coefficient vector of <span>$a$</span> modulo <span>$m$</span> and returns the corresponding element. The coefficient vector of the result will have entries <span>$x$</span> with <span>$0 \leq x \leq m$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.powermod-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},fmpz,Int64}" href="#Base.powermod-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},fmpz,Int64}"><code>Base.powermod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">powermod(a::NfAbsOrdElem, i::fmpz, m::Integer) -&gt; NfAbsOrdElem</code></pre><p>Returns the element <span>$a^i$</span> modulo <span>$m$</span>.</p></div></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Nemo.representation_matrix-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Nemo.representation_matrix-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Nemo.representation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representation_matrix(a::NfAbsOrdElem) -&gt; fmpz_mat</code></pre><p>Returns the representation matrix of the element <span>$a$</span>.</p></div></section><section><div><pre><code class="language-julia">representation_matrix(a::NfAbsOrdElem, K::AnticNumberField) -&gt; FakeFmpqMat</code></pre><p>Returns the representation matrix of the element <span>$a$</span> considered as an element of the ambient number field <span>$K$</span>. It is assumed that <span>$K$</span> is the ambient number field of the order of <span>$a$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.representation_matrix-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},AnticNumberField}" href="#Nemo.representation_matrix-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},AnticNumberField}"><code>Nemo.representation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representation_matrix(a::NfAbsOrdElem, K::AnticNumberField) -&gt; FakeFmpqMat</code></pre><p>Returns the representation matrix of the element <span>$a$</span> considered as an element of the ambient number field <span>$K$</span>. It is assumed that <span>$K$</span> is the ambient number field of the order of <span>$a$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.tr-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#LinearAlgebra.tr-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tr(a::NfAbsOrdElem) -&gt; fmpz</code></pre><p>Returns the trace of <span>$a$</span>.</p></div></section><section><div><pre><code class="language-none">tr(x::AbsAlgAssElem{T}) where T -&gt; T</code></pre><p>Returns the trace of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#LinearAlgebra.norm-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(a::NfRelOrdIdl) -&gt; NfOrdIdl</code></pre><p>Returns the norm of <span>$a$</span>.</p></div></section><section><div><pre><code class="language-none">norm(a::NfRelOrdFracIdl{T, S}) -&gt; S</code></pre><p>Returns the norm of <span>$a$</span>.</p></div></section><section><div><pre><code class="language-none">norm(a::NfAbsOrdElem) -&gt; fmpz</code></pre><p>Returns the norm of <span>$a$</span>.</p></div></section><section><div><pre><code class="language-none">norm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -&gt; fmpq</code></pre><p>Returns the norm of <span>$a$</span> considered as an (possibly fractional) ideal of <span>$O$</span>.</p></div></section><section><div><pre><code class="language-none">norm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true)
  where { S, T, U } -&gt; T</code></pre><p>Returns the norm of <span>$a$</span> considered as an (possibly fractional) ideal of <span>$O$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{NfAbsOrd{AnticNumberField,nf_elem},Int64}" href="#Base.rand-Tuple{NfAbsOrd{AnticNumberField,nf_elem},Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand(O::NfOrd, n::Union{Integer, fmpz}) -&gt; NfAbsOrdElem</code></pre><p>Computes a coefficient vector with entries uniformly distributed in <span>$\{-n,\dotsc,-1,0,1,\dotsc,n\}$</span> and returns the corresponding element of the order <span>$\mathcal O$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.minkowski_map-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Hecke.minkowski_map-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Hecke.minkowski_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minkowski_map(a::NfAbsOrdElem, abs_tol::Int) -&gt; Array{arb, 1}</code></pre><p>Returns the image of <span>$a$</span> under the Minkowski embedding. Every entry of the array returned is of type <code>arb</code> with radius less then <code>2^-abs_tol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.conjugates_arb-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Hecke.conjugates_arb-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Hecke.conjugates_arb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conjugates_arb(x::NfAbsOrdElem, abs_tol::Int) -&gt; Array{acb, 1}</code></pre><p>Compute the conjugates of <code>x</code> as elements of type <code>acb</code>. Recall that we order the complex conjugates <span>$\sigma_{r+1}(x),...,\sigma_{r+2s}(x)$</span> such that <span>$\sigma_{i}(x) = \overline{\sigma_{i + s}(x)}$</span> for <span>$r + 2 \leq i \leq r + s$</span>.</p><p>Every entry <code>y</code> of the array returned satisfies <code>radius(real(y)) &lt; 2^-abs_tol</code>, <code>radius(imag(y)) &lt; 2^-abs_tol</code> respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.conjugates_arb_log-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Hecke.conjugates_arb_log-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Hecke.conjugates_arb_log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conjugates_arb_log(x::NfAbsOrdElem, abs_tol::Int) -&gt; Array{arb, 1}</code></pre><p>Returns the elements <span>$(\log(\lvert \sigma_1(x) \rvert),\dotsc,\log(\lvert\sigma_r(x) \rvert), \dotsc,2\log(\lvert \sigma_{r+1}(x) \rvert),\dotsc, 2\log(\lvert \sigma_{r+s}(x)\rvert))$</span> as elements of type <code>arb</code> radius less then <code>2^-abs_tol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.t2-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}" href="#Hecke.t2-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem},Int64}"><code>Hecke.t2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">t2(x::NfAbsOrdElem, abs_tol::Int = 32) -&gt; arb</code></pre><p>Return the <span>$T_2$</span>-norm of <span>$x$</span>. The radius of the result will be less than <code>2^-abs_tol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.minpoly-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.minpoly-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.minpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T &lt;: RingElement}</code></pre><p>Return the minimal polynomial <span>$p$</span> of the matrix <span>$M$</span>. The polynomial ring <span>$S$</span> of the resulting polynomial must be supplied and the matrix must be square.</p></div></section><section><div><pre><code class="language-none">minpoly(S::Ring, M::MatAlgElem{T}, charpoly_only::Bool = false) where {T &lt;: RingElement}</code></pre><p>Return the minimal polynomial <span>$p$</span> of the matrix <span>$M$</span>. The polynomial ring <span>$S$</span> of the resulting polynomial must be supplied and the matrix must be square.</p></div></section><section><div><pre><code class="language-none">minpoly(a::NfRelElem) -&gt; PolyElem</code></pre><p>Given an element <span>$a$</span> in an extension <span>$L/K$</span>, this function returns the minimal polynomial of <span>$a$</span> over <span>$K$</span>.</p></div></section><section><div><pre><code class="language-none">minpoly(a::NfAbsOrdElem) -&gt; fmpz_poly</code></pre><p>The minimal polynomial of <span>$a$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.charpoly-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#AbstractAlgebra.Generic.charpoly-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>AbstractAlgebra.Generic.charpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">charpoly(V::Ring, Y::Generic.MatrixElem{T}) where {T &lt;: RingElement}</code></pre><p>Return the characteristic polynomial <span>$p$</span> of the matrix <span>$M$</span>. The polynomial ring <span>$R$</span> of the resulting polynomial must be supplied and the matrix is assumed to be square.</p></div></section><section><div><pre><code class="language-none">charpoly(a::NfAbsOrdElem) -&gt; fmpz_poly
charpoly(a::NfAbsOrdElem, FlintZZ) -&gt; fmpz_poly</code></pre><p>The characteristic polynomial of <span>$a$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Hecke.factor-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}" href="#Hecke.factor-Tuple{NfAbsOrdElem{AnticNumberField,nf_elem}}"><code>Hecke.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(a::NfOrdElem) -&gt; Fac{NfOrdElem}</code></pre><p>Computes a factorization of <code>a</code> into irreducible elements. The return value is a factorization <code>fac</code>, which satisfies <code>a = unit(fac) * prod(p^e for (p, e) in fac)</code>.</p><p>The function requires that <code>a</code> is non-zero and that all prime ideals containing <code>a</code> are principal, which is for example satisfied if class group of the order of <code>a</code> is trivial.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../orders/">« Orders</a><a class="docs-footer-nextpage" href="../ideals/">Ideals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 11 February 2021 10:26">Thursday 11 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
