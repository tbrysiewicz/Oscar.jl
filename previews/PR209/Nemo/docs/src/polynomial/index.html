<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Univariate polynomials · Oscar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Oscar.jl</span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Welcome to Oscar</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/rings/">Ring Interface</a></li><li><a class="tocitem" href="../../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/polynomial/">Generic univariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/mpolynomial/">Generic sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../Hecke/docs/src/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../Hecke/docs/src/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../../../Hecke/docs/src/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../../../Hecke/docs/src/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../../../Hecke/docs/src/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/series_rings/">Series Ring Interface</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/series/">Generic power series</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../puiseux/">Puiseux series</a></li></ul></li><li><a class="tocitem" href="../../../../Rings/affine/">Affine Rings</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../../../Rings/rational/">Rationals</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../Hecke/docs/src/number_fields/intro/">Number Fields</a></li><li><a class="tocitem" href="../../../../Hecke/docs/src/number_fields/basics/">-</a></li><li><a class="tocitem" href="../../../../Hecke/docs/src/number_fields/elements/">-</a></li></ul></li><li><a class="tocitem" href="../../../../Hecke/docs/src/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../../../Hecke/docs/src/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/fraction_fields/">Fraction Field Interface</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-3-9" type="checkbox"/><label class="tocitem" for="menuitem-3-9"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../padic/">Padics</a></li><li><a class="tocitem" href="../qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../finitefield/">Finite fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../../../../Groups/groups/">Groups</a></li><li><a class="tocitem" href="../../../../Hecke/docs/src/abelian/introduction/">Abelian Groups</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../../../Hecke/docs/src/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/matrix_spaces/">Matrix Interface</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/matrix/">Generic matrices</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/module/">Module Interface</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../../AbstractAlgebra/docs/src/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../Hecke/docs/src/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../Hecke/docs/src/quad_forms/basics/">Basics</a></li><li><a class="tocitem" href="../../../../Hecke/docs/src/quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Univariate polynomials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Univariate polynomials</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Univariate-polynomials"><a class="docs-heading-anchor" href="#Univariate-polynomials">Univariate polynomials</a><a id="Univariate-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-polynomials" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Nemo allow the creation of dense, univariate polynomials over any computable ring <span>$R$</span>. There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.</p><p>The following table shows each of the polynomial types available in Nemo, the base ring <span>$R$</span>, and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).</p><table><tr><th style="text-align: right">Base ring</th><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Generic ring <span>$R$</span></td><td style="text-align: right">AbstractAlgebra.jl</td><td style="text-align: right"><code>Generic.Poly{T}</code></td><td style="text-align: right"><code>Generic.PolyRing{T}</code></td></tr><tr><td style="text-align: right"><span>$\mathbb{Z}$</span></td><td style="text-align: right">Flint</td><td style="text-align: right"><code>fmpz_poly</code></td><td style="text-align: right"><code>FmpzPolyRing</code></td></tr><tr><td style="text-align: right"><span>$\mathbb{Z}/n\mathbb{Z}$</span> (small <span>$n$</span>)</td><td style="text-align: right">Flint</td><td style="text-align: right"><code>nmod_poly</code></td><td style="text-align: right"><code>NmodPolyRing</code></td></tr><tr><td style="text-align: right"><span>$\mathbb{Z}/n\mathbb{Z}$</span> (large <span>$n$</span>)</td><td style="text-align: right">Flint</td><td style="text-align: right"><code>fmpz_mod_poly</code></td><td style="text-align: right"><code>FmpzModPolyRing</code></td></tr><tr><td style="text-align: right"><span>$\mathbb{Q}$</span></td><td style="text-align: right">Flint</td><td style="text-align: right"><code>fmpq_poly</code></td><td style="text-align: right"><code>FmpqPolyRing</code></td></tr><tr><td style="text-align: right"><span>$\mathbb{Z}/p\mathbb{Z}$</span> (small prime <span>$p$</span>)</td><td style="text-align: right">Flint</td><td style="text-align: right"><code>gfp_poly</code></td><td style="text-align: right"><code>GFPPolyRing</code></td></tr><tr><td style="text-align: right"><span>$\mathbb{Z}/p\mathbb{Z}$</span> (large prime <span>$p$</span>)</td><td style="text-align: right">Flint</td><td style="text-align: right"><code>gfp_fmpz_poly</code></td><td style="text-align: right"><code>GFPFmpzPolyRing</code></td></tr><tr><td style="text-align: right"><span>$\mathbb{F}_{p^n}$</span> (small <span>$p$</span>)</td><td style="text-align: right">Flint</td><td style="text-align: right"><code>fq_nmod_poly</code></td><td style="text-align: right"><code>FqNmodPolyRing</code></td></tr><tr><td style="text-align: right"><span>$\mathbb{F}_{p^n}$</span> (large <span>$p$</span>)</td><td style="text-align: right">Flint</td><td style="text-align: right"><code>fq_poly</code></td><td style="text-align: right"><code>FqPolyRing</code></td></tr><tr><td style="text-align: right"><span>$\mathbb{R}$</span></td><td style="text-align: right">Arb</td><td style="text-align: right"><code>arb_poly</code></td><td style="text-align: right"><code>ArbPolyRing</code></td></tr><tr><td style="text-align: right"><span>$\mathbb{C}$</span></td><td style="text-align: right">Arb</td><td style="text-align: right"><code>acb_poly</code></td><td style="text-align: right"><code>AcbPolyRing</code></td></tr></table><p>The string representation of the variable and the base ring <span>$R$</span> of a generic polynomial is stored in its parent object. </p><p>All polynomial element types belong to the abstract type <code>PolyElem</code> and all of the polynomial ring types belong to the abstract type <code>PolyRing</code>. This enables one to write generic functions that can accept any Nemo univariate polynomial type.</p><h2 id="Polynomial-functionality"><a class="docs-heading-anchor" href="#Polynomial-functionality">Polynomial functionality</a><a id="Polynomial-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-functionality" title="Permalink"></a></h2><p>All univariate polynomial types in Nemo follow the AbstractAlgebra.jl univariate polynomial interface:</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/latest/polynomial_rings">https://nemocas.github.io/AbstractAlgebra.jl/latest/polynomial_rings</a></p><p>Generic polynomials are also available, and Nemo univariate polynomial types also implement all of the same functionality.</p><p>We describe here only functions that are in addition to that guaranteed by AbstractAlgebra.jl, for specific coefficient rings.</p><h3 id="Remove-and-valuation"><a class="docs-heading-anchor" href="#Remove-and-valuation">Remove and valuation</a><a id="Remove-and-valuation-1"></a><a class="docs-heading-anchor-permalink" href="#Remove-and-valuation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,Integer}" href="#Nemo.evaluate2-Tuple{arb_poly,Integer}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::arb_poly, y::Integer)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,Float64}" href="#Nemo.evaluate2-Tuple{arb_poly,Float64}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::arb_poly, y::Float64)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,fmpz}" href="#Nemo.evaluate2-Tuple{arb_poly,fmpz}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::arb_poly, y::fmpz)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,fmpq}" href="#Nemo.evaluate2-Tuple{arb_poly,fmpq}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::arb_poly, y::fmpq)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,arb}" href="#Nemo.evaluate2-Tuple{arb_poly,arb}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::arb_poly, y::arb)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{arb_poly,acb}" href="#Nemo.evaluate2-Tuple{arb_poly,acb}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::arb_poly, y::acb)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,Integer}" href="#Nemo.evaluate2-Tuple{acb_poly,Integer}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::acb_poly, y::Integer)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,Float64}" href="#Nemo.evaluate2-Tuple{acb_poly,Float64}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::acb_poly, y::Float64)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,fmpz}" href="#Nemo.evaluate2-Tuple{acb_poly,fmpz}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::acb_poly, y::fmpz)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,fmpq}" href="#Nemo.evaluate2-Tuple{acb_poly,fmpq}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::acb_poly, y::fmpq)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,arb}" href="#Nemo.evaluate2-Tuple{acb_poly,arb}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::acb_poly, y::arb)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.evaluate2-Tuple{acb_poly,acb}" href="#Nemo.evaluate2-Tuple{acb_poly,acb}"><code>Nemo.evaluate2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate2(x::acb_poly, y::acb)</code></pre><p>Return a tuple <span>$p, q$</span> consisting of the polynomial <span>$x$</span> evaluated at <span>$y$</span> and its derivative evaluated at <span>$y$</span>.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">RR = RealField(64)
T, z = PolynomialRing(RR, &quot;z&quot;)
   
h = z^2 + 2z + 1

s, t = evaluate2(h, RR(&quot;2.0 +/- 0.1&quot;))</code></pre><h3 id="Signature"><a class="docs-heading-anchor" href="#Signature">Signature</a><a id="Signature-1"></a><a class="docs-heading-anchor-permalink" href="#Signature" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Nemo.signature-Tuple{fmpz_poly}" href="#Nemo.signature-Tuple{fmpz_poly}"><code>Nemo.signature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">signature(f::fmpz_poly)</code></pre><p>Return the signature of the polynomial <span>$f$</span>, i.e. a tuple <span>$(r, s)$</span> such that <span>$r$</span> is the number of real roots of <span>$f$</span> and <span>$s$</span> is half the number of complex roots.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.signature-Tuple{fmpq_poly}" href="#Nemo.signature-Tuple{fmpq_poly}"><code>Nemo.signature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">signature(f::fmpq_poly)</code></pre><p>Return the signature of <span>$f$</span>, i.e. a tuple <span>$(r, s)$</span> where <span>$r$</span> is the number of real roots of <span>$f$</span> and <span>$s$</span> is half the number of complex roots.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, x = PolynomialRing(ZZ, &quot;x&quot;)

f = x^3 + 3x + 1

(r, s) = signature(f)</code></pre><h3 id="Root-finding"><a class="docs-heading-anchor" href="#Root-finding">Root finding</a><a id="Root-finding-1"></a><a class="docs-heading-anchor-permalink" href="#Root-finding" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Nemo.roots-Tuple{acb_poly}" href="#Nemo.roots-Tuple{acb_poly}"><code>Nemo.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">roots(x::acb_poly; target=0, isolate_real=false, initial_prec=0, max_prec=0, max_iter=0)</code></pre><p>Attempts to isolate the complex roots of the complex polynomial <span>$x$</span> by iteratively refining balls in which they lie.</p><p>This is done by increasing the working precision, starting at <code>initial_prec</code>. The maximal number of iterations can be set using <code>max_iter</code> and the maximal precision can be set using <code>max_prec</code>.</p><p>If <code>isolate_real</code> is set and <span>$x$</span> is strictly real, then the real roots will be isolated from the non-real roots. Every root will have either zero, positive or negative real part.</p><p>It is assumed that <span>$x$</span> is squarefree.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">CC = ComplexField(64)
C, y = PolynomialRing(CC, &quot;y&quot;)

m = y^2 + 2y + 3
n = m + CC(&quot;0 +/- 0.0001&quot;, &quot;0 +/- 0.0001&quot;)

r = roots(n)

p = y^7 - 1

r = roots(n, isolate_real = true)</code></pre><h3 id="Construction-from-roots"><a class="docs-heading-anchor" href="#Construction-from-roots">Construction from roots</a><a id="Construction-from-roots-1"></a><a class="docs-heading-anchor-permalink" href="#Construction-from-roots" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Nemo.from_roots-Tuple{ArbPolyRing,Array{arb,1}}" href="#Nemo.from_roots-Tuple{ArbPolyRing,Array{arb,1}}"><code>Nemo.from_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_roots(R::ArbPolyRing, b::Array{arb, 1})</code></pre><p>Construct a polynomial in the given polynomial ring from a list of its roots.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.from_roots-Tuple{AcbPolyRing,Array{acb,1}}" href="#Nemo.from_roots-Tuple{AcbPolyRing,Array{acb,1}}"><code>Nemo.from_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_roots(R::AcbPolyRing, b::Array{acb, 1})</code></pre><p>Construct a polynomial in the given polynomial ring from a list of its roots.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">RR = RealField(64)
R, x = PolynomialRing(RR, &quot;x&quot;)

xs = arb[inv(RR(i)) for i=1:5]
f = from_roots(R, xs)</code></pre><h3 id="Bounding-absolute-values-of-roots"><a class="docs-heading-anchor" href="#Bounding-absolute-values-of-roots">Bounding absolute values of roots</a><a id="Bounding-absolute-values-of-roots-1"></a><a class="docs-heading-anchor-permalink" href="#Bounding-absolute-values-of-roots" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Nemo.roots_upper_bound-Tuple{arb_poly}" href="#Nemo.roots_upper_bound-Tuple{arb_poly}"><code>Nemo.roots_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">roots_upper_bound(x::arb_poly) -&gt; arb</code></pre><p>Returns an upper bound for the absolute value of all complex roots of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.roots_upper_bound-Tuple{acb_poly}" href="#Nemo.roots_upper_bound-Tuple{acb_poly}"><code>Nemo.roots_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">roots_upper_bound(x::acb_poly) -&gt; arb</code></pre><p>Returns an upper bound for the absolute value of all complex roots of <span>$x$</span>.</p></div></section></article><h3 id="Lifting"><a class="docs-heading-anchor" href="#Lifting">Lifting</a><a id="Lifting-1"></a><a class="docs-heading-anchor-permalink" href="#Lifting" title="Permalink"></a></h3><p>When working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from <span>$\mathbb{Z}/n\mathbb{Z}$</span> to <span>$\mathbb{Z}$</span>.</p><article class="docstring"><header><a class="docstring-binding" id="Nemo.lift-Tuple{FmpzPolyRing,nmod_poly}" href="#Nemo.lift-Tuple{FmpzPolyRing,nmod_poly}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function lift(R::FmpzPolyRing, y::nmod_poly)</code></pre><p>Lift from a polynomial over <span>$\mathbb{Z}/n\mathbb{Z}$</span> to a polynomial over <span>$\mathbb{Z}$</span> with minimal reduced nonnegative coefficients. The ring <code>R</code> specifies the ring to lift into.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.lift-Tuple{FmpzPolyRing,gfp_poly}" href="#Nemo.lift-Tuple{FmpzPolyRing,gfp_poly}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lift(R::FmpzPolyRing, y::gfp_poly)</code></pre><p>Lift from a polynomial over <span>$\mathbb{Z}/n\mathbb{Z}$</span> to a polynomial over <span>$\mathbb{Z}$</span> with minimal reduced nonnegative coefficients. The ring <code>R</code> specifies the ring to lift into.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.lift-Tuple{FmpzPolyRing,fmpz_mod_poly}" href="#Nemo.lift-Tuple{FmpzPolyRing,fmpz_mod_poly}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function lift(R::FmpzPolyRing, y::fmpz_mod_poly)</code></pre><p>Lift from a polynomial over <span>$\mathbb{Z}/n\mathbb{Z}$</span> to a polynomial over <span>$\mathbb{Z}$</span> with minimal reduced nonnegative coefficients. The ring <code>R</code> specifies the ring to lift into.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.lift-Tuple{FmpzPolyRing,gfp_fmpz_poly}" href="#Nemo.lift-Tuple{FmpzPolyRing,gfp_fmpz_poly}"><code>Nemo.lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function lift(R::FmpzPolyRing, y::gfp_fmpz_poly)</code></pre><p>Lift from a polynomial over <span>$\mathbb{Z}/n\mathbb{Z}$</span> to a polynomial over <span>$\mathbb{Z}$</span> with minimal reduced nonnegative coefficients. The ring <code>R</code> specifies the ring to lift into.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R = ResidueRing(ZZ, 123456789012345678949)
S, x = PolynomialRing(R, &quot;x&quot;)
T, y = PolynomialRing(ZZ, &quot;y&quot;)

f = x^2 + 2x + 1

a = lift(T, f)</code></pre><h3 id="Overlapping-and-containment"><a class="docs-heading-anchor" href="#Overlapping-and-containment">Overlapping and containment</a><a id="Overlapping-and-containment-1"></a><a class="docs-heading-anchor-permalink" href="#Overlapping-and-containment" title="Permalink"></a></h3><p>Occasionally it is useful to be able to tell when inexact polynomials overlap or contain other exact or inexact polynomials. The following functions are provided for this purpose.</p><article class="docstring"><header><a class="docstring-binding" id="Nemo.overlaps-Tuple{arb_poly,arb_poly}" href="#Nemo.overlaps-Tuple{arb_poly,arb_poly}"><code>Nemo.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">overlaps(x::arb_poly, y::arb_poly)</code></pre><p>Return <code>true</code> if the coefficient balls of <span>$x$</span> overlap the coefficient balls of <span>$y$</span>, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.overlaps-Tuple{acb_poly,acb_poly}" href="#Nemo.overlaps-Tuple{acb_poly,acb_poly}"><code>Nemo.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">overlaps(x::acb_poly, y::acb_poly)</code></pre><p>Return <code>true</code> if the coefficient boxes of <span>$x$</span> overlap the coefficient boxes of <span>$y$</span>, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{arb_poly,arb_poly}" href="#Base.contains-Tuple{arb_poly,arb_poly}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contains(x::arb_poly, y::arb_poly)</code></pre><p>Return <code>true</code> if the coefficient balls of <span>$x$</span> contain the corresponding coefficient balls of <span>$y$</span>, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{acb_poly,acb_poly}" href="#Base.contains-Tuple{acb_poly,acb_poly}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contains(x::acb_poly, y::acb_poly)</code></pre><p>Return <code>true</code> if the coefficient boxes of <span>$x$</span> contain the corresponding coefficient boxes of <span>$y$</span>, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{arb_poly,fmpz_poly}" href="#Base.contains-Tuple{arb_poly,fmpz_poly}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contains(x::arb_poly, y::fmpz_poly)</code></pre><p>Return <code>true</code> if the coefficient balls of <span>$x$</span> contain the corresponding exact coefficients of <span>$y$</span>, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{arb_poly,fmpq_poly}" href="#Base.contains-Tuple{arb_poly,fmpq_poly}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contains(x::arb_poly, y::fmpq_poly)</code></pre><p>Return <code>true</code> if the coefficient balls of <span>$x$</span> contain the corresponding exact coefficients of <span>$y$</span>, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{acb_poly,fmpz_poly}" href="#Base.contains-Tuple{acb_poly,fmpz_poly}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contains(x::acb_poly, y::fmpz_poly)</code></pre><p>Return <code>true</code> if the coefficient boxes of <span>$x$</span> contain the corresponding exact coefficients of <span>$y$</span>, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{acb_poly,fmpq_poly}" href="#Base.contains-Tuple{acb_poly,fmpq_poly}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contains(x::acb_poly, y::fmpq_poly)</code></pre><p>Return <code>true</code> if the coefficient boxes of <span>$x$</span> contain the corresponding exact coefficients of <span>$y$</span>, otherwise return <code>false</code>.</p></div></section></article><p>It is sometimes also useful to be able to determine if there is a unique integer contained in the coefficient of an inexact constant polynomial.</p><article class="docstring"><header><a class="docstring-binding" id="Nemo.unique_integer-Tuple{arb_poly}" href="#Nemo.unique_integer-Tuple{arb_poly}"><code>Nemo.unique_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unique_integer(x::arb_poly)</code></pre><p>Return a tuple <code>(t, z)</code> where <span>$t$</span> is <code>true</code> if there is a unique integer contained in each of the coefficients of <span>$x$</span>, otherwise sets <span>$t$</span> to <code>false</code>. In the former case, <span>$z$</span> is set to the integer polynomial.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.unique_integer-Tuple{acb_poly}" href="#Nemo.unique_integer-Tuple{acb_poly}"><code>Nemo.unique_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unique_integer(x::acb_poly)</code></pre><p>Return a tuple <code>(t, z)</code> where <span>$t$</span> is <code>true</code> if there is a unique integer contained in the (constant) polynomial <span>$x$</span>, along with that integer <span>$z$</span> in case it is, otherwise sets <span>$t$</span> to <code>false</code>.</p></div></section></article><p>We also have the following functions.</p><article class="docstring"><header><a class="docstring-binding" id="Base.isreal-Tuple{acb_poly}" href="#Base.isreal-Tuple{acb_poly}"><code>Base.isreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isreal(x::acb_poly)</code></pre><p>Return <code>true</code> if all the coefficients of <span>$x$</span> are real, i.e. have exact zero imaginary parts.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">RR = RealField(64)
CC = ComplexField(64)
R, x = PolynomialRing(RR, &quot;x&quot;)
C, y = PolynomialRing(CC, &quot;y&quot;)
Zx, zx = PolynomialRing(ZZ, &quot;x&quot;)
Qx, qx = PolynomialRing(QQ, &quot;x&quot;)

f = x^2 + 2x + 1
h = f + RR(&quot;0 +/- 0.0001&quot;)
k = f + RR(&quot;0 +/- 0.0001&quot;) * x^4
m = y^2 + 2y + 1
n = m + CC(&quot;0 +/- 0.0001&quot;, &quot;0 +/- 0.0001&quot;)

contains(h, f)
overlaps(f, k)
contains(n, m)
t, z = unique_integer(k)
isreal(n)</code></pre><h3 id="Factorisation"><a class="docs-heading-anchor" href="#Factorisation">Factorisation</a><a id="Factorisation-1"></a><a class="docs-heading-anchor-permalink" href="#Factorisation" title="Permalink"></a></h3><p>Polynomials can be factorised over certain rings. In general we use the same format for the output as the Julia factorisation function, namely an associative array with polynomial factors as keys and exponents as values.</p><article class="docstring"><header><a class="docstring-binding" id="Nemo.isirreducible-Tuple{nmod_poly}" href="#Nemo.isirreducible-Tuple{nmod_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isirreducible(x::nmod_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.isirreducible-Tuple{gfp_poly}" href="#Nemo.isirreducible-Tuple{gfp_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isirreducible(x::gfp_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.isirreducible-Tuple{fmpz_mod_poly}" href="#Nemo.isirreducible-Tuple{fmpz_mod_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isirreducible(x::fmpz_mod_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.isirreducible-Tuple{gfp_fmpz_poly}" href="#Nemo.isirreducible-Tuple{gfp_fmpz_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isirreducible(x::gfp_fmpz_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.isirreducible-Tuple{fq_poly}" href="#Nemo.isirreducible-Tuple{fq_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isirreducible(x::fq_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.isirreducible-Tuple{fq_nmod_poly}" href="#Nemo.isirreducible-Tuple{fq_nmod_poly}"><code>Nemo.isirreducible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isirreducible(x::fq_nmod_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is irreducible, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.issquarefree-Tuple{nmod_poly}" href="#Nemo.issquarefree-Tuple{nmod_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issquarefree(x::nmod_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.issquarefree-Tuple{gfp_poly}" href="#Nemo.issquarefree-Tuple{gfp_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issquarefree(x::gfp_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.issquarefree-Tuple{fmpz_mod_poly}" href="#Nemo.issquarefree-Tuple{fmpz_mod_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issquarefree(x::fmpz_mod_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.issquarefree-Tuple{gfp_fmpz_poly}" href="#Nemo.issquarefree-Tuple{gfp_fmpz_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issquarefree(x::gfp_fmpz_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.issquarefree-Tuple{fq_poly}" href="#Nemo.issquarefree-Tuple{fq_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issquarefree(x::fq_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.issquarefree-Tuple{fq_nmod_poly}" href="#Nemo.issquarefree-Tuple{fq_nmod_poly}"><code>Nemo.issquarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issquarefree(x::fq_nmod_poly)</code></pre><p>Return <code>true</code> if <span>$x$</span> is squarefree, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor-Tuple{fmpz_poly}" href="#AbstractAlgebra.factor-Tuple{fmpz_poly}"><code>AbstractAlgebra.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(x::fmpz_poly)</code></pre><p>Returns the factorization of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor-Tuple{nmod_poly}" href="#AbstractAlgebra.factor-Tuple{nmod_poly}"><code>AbstractAlgebra.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(x::nmod_poly)</code></pre><p>Return the factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor-Tuple{gfp_poly}" href="#AbstractAlgebra.factor-Tuple{gfp_poly}"><code>AbstractAlgebra.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(x::gfp_poly)</code></pre><p>Return the factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor-Tuple{fmpz_mod_poly}" href="#AbstractAlgebra.factor-Tuple{fmpz_mod_poly}"><code>AbstractAlgebra.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(x::fmpz_mod_poly)</code></pre><p>Return the factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor-Tuple{gfp_fmpz_poly}" href="#AbstractAlgebra.factor-Tuple{gfp_fmpz_poly}"><code>AbstractAlgebra.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(x::gfp_fmpz_poly)</code></pre><p>Return the factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor-Tuple{fq_poly}" href="#AbstractAlgebra.factor-Tuple{fq_poly}"><code>AbstractAlgebra.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(x::fq_poly)</code></pre><p>Return the factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor-Tuple{fq_nmod_poly}" href="#AbstractAlgebra.factor-Tuple{fq_nmod_poly}"><code>AbstractAlgebra.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(x::fq_nmod_poly)</code></pre><p>Return the factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor_squarefree-Tuple{nmod_poly}" href="#AbstractAlgebra.factor_squarefree-Tuple{nmod_poly}"><code>AbstractAlgebra.factor_squarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_squarefree(x::nmod_poly)</code></pre><p>Return the squarefree factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor_squarefree-Tuple{gfp_poly}" href="#AbstractAlgebra.factor_squarefree-Tuple{gfp_poly}"><code>AbstractAlgebra.factor_squarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_squarefree(x::gfp_poly)</code></pre><p>Return the squarefree factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor_squarefree-Tuple{fmpz_mod_poly}" href="#AbstractAlgebra.factor_squarefree-Tuple{fmpz_mod_poly}"><code>AbstractAlgebra.factor_squarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_squarefree(x::fmpz_mod_poly)</code></pre><p>Return the squarefree factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor_squarefree-Tuple{gfp_fmpz_poly}" href="#AbstractAlgebra.factor_squarefree-Tuple{gfp_fmpz_poly}"><code>AbstractAlgebra.factor_squarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_squarefree(x::gfp_fmpz_poly)</code></pre><p>Return the squarefree factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor_squarefree-Tuple{fq_poly}" href="#AbstractAlgebra.factor_squarefree-Tuple{fq_poly}"><code>AbstractAlgebra.factor_squarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_squarefree(x::fq_poly)</code></pre><p>Return the squarefree factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.factor_squarefree-Tuple{fq_nmod_poly}" href="#AbstractAlgebra.factor_squarefree-Tuple{fq_nmod_poly}"><code>AbstractAlgebra.factor_squarefree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_squarefree(x::fq_nmod_poly)</code></pre><p>Return the squarefree factorisation of <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{nmod_poly}" href="#Nemo.factor_distinct_deg-Tuple{nmod_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_distinct_deg(x::nmod_poly)</code></pre><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{gfp_poly}" href="#Nemo.factor_distinct_deg-Tuple{gfp_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_distinct_deg(x::gfp_poly)</code></pre><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{fmpz_mod_poly}" href="#Nemo.factor_distinct_deg-Tuple{fmpz_mod_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_distinct_deg(x::fmpz_mod_poly)</code></pre><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{gfp_fmpz_poly}" href="#Nemo.factor_distinct_deg-Tuple{gfp_fmpz_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_distinct_deg(x::fmpz_mod_poly)</code></pre><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{fq_poly}" href="#Nemo.factor_distinct_deg-Tuple{fq_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_distinct_deg(x::fq_poly)</code></pre><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.factor_distinct_deg-Tuple{fq_nmod_poly}" href="#Nemo.factor_distinct_deg-Tuple{fq_nmod_poly}"><code>Nemo.factor_distinct_deg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor_distinct_deg(x::fq_nmod_poly)</code></pre><p>Return the distinct degree factorisation of a squarefree polynomial <span>$x$</span>.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-none">R = ResidueRing(ZZ, 23)
S, x = PolynomialRing(R, &quot;x&quot;)

f = x^2 + 2x + 1
g = x^3 + 3x + 1

R = factor(f*g)
S = factor_squarefree(f*g)
T = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))</code></pre><h3 id="Special-functions"><a class="docs-heading-anchor" href="#Special-functions">Special functions</a><a id="Special-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Special-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Nemo.cyclotomic-Tuple{Int64,fmpz_poly}" href="#Nemo.cyclotomic-Tuple{Int64,fmpz_poly}"><code>Nemo.cyclotomic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cyclotomic(n::Int, x::fmpz_poly)</code></pre><p>Return the <span>$n$</span>th cyclotomic polynomial, defined as <span>$\Phi_n(x) = \prod_{\omega} (x-\omega),$</span> where <span>$\omega$</span> runs over all the <span>$n$</span>th primitive roots of unity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.swinnerton_dyer-Tuple{Int64,fmpz_poly}" href="#Nemo.swinnerton_dyer-Tuple{Int64,fmpz_poly}"><code>Nemo.swinnerton_dyer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swinnerton_dyer(n::Int, x::fmpz_poly)</code></pre><p>Return the Swinnerton-Dyer polynomial <span>$S_n$</span>, defined as the integer polynomial <span>$S_n = \prod (x \pm \sqrt{2} \pm \sqrt{3} \pm \sqrt{5} \pm \ldots \pm \sqrt{p_n})$</span> where <span>$p_n$</span> denotes the <span>$n$</span>-th prime number and all combinations of signs are taken. This polynomial has degree <span>$2^n$</span> and is irreducible over the integers (it is the minimal polynomial of <span>$\sqrt{2} + \ldots + \sqrt{p_n}$</span>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.cos_minpoly-Tuple{Int64,fmpz_poly}" href="#Nemo.cos_minpoly-Tuple{Int64,fmpz_poly}"><code>Nemo.cos_minpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cos_minpoly(n::Int, x::fmpz_poly)</code></pre><p>Return the minimal polynomial of <span>$2 \cos(2 \pi / n)$</span>. For suitable choice of <span>$n$</span>, this gives the minimal polynomial of <span>$2 \cos(a \pi)$</span> or <span>$2 \sin(a \pi)$</span> for any rational <span>$a$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.theta_qexp-Tuple{Int64,Int64,fmpz_poly}" href="#Nemo.theta_qexp-Tuple{Int64,Int64,fmpz_poly}"><code>Nemo.theta_qexp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">theta_qexp(e::Int, n::Int, x::fmpz_poly)</code></pre><p>Return the <span>$q$</span>-expansion to length <span>$n$</span> of the Jacobi theta function raised to the power <span>$r$</span>, i.e. <span>$\vartheta(q)^r$</span> where <span>$\vartheta(q) = 1 + \sum_{k=1}^{\infty} q^{k^2}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Nemo.eta_qexp-Tuple{Int64,Int64,fmpz_poly}" href="#Nemo.eta_qexp-Tuple{Int64,Int64,fmpz_poly}"><code>Nemo.eta_qexp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eta_qexp(e::Int, n::Int, x::fmpz_poly)</code></pre><p>Return the <span>$q$</span>-expansion to length <span>$n$</span> of the Dedekind eta function (without the leading factor <span>$q^{1/24}$</span>) raised to the power <span>$r$</span>, i.e. <span>$(q^{-1/24} \eta(q))^r = \prod_{k=1}^{\infty} (1 - q^k)^r$</span>. In particular, <span>$r = -1$</span> gives the generating function of the partition function <span>$p(k)$</span>, and <span>$r = 24$</span> gives, after multiplication by <span>$q$</span>, the modular discriminant <span>$\Delta(q)$</span> which generates the Ramanujan tau function <span>$\tau(k)$</span>.</p></div></section></article><p><strong>Examples</strong></p><pre><code class="language-julia">R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

h = cyclotomic(120, x)
j = swinnerton_dyer(5, x)
k = cos_minpoly(30, x)
l = theta_qexp(3, 30, x)
m = eta_qexp(24, 30, x)
o = cyclotomic(10, 1 + x + x^2)</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 19 January 2021 12:28">Tuesday 19 January 2021</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
